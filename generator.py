# what 

# Generators are a powerful feature in Python that allow you to create iterators in a more efficient and concise manner. In this explanation, I'll cover the basics of generators, how to define them, iterate over them, and their advantages over regular functions and lists. I'll also discuss generator expressions, using generators in combination with other Python features, and advanced topics such as coroutine-like behavior and the yield from statement.

# Basics of Generators:

# What is a generator? A generator is a special type of iterator that generates values on the fly instead of storing them in memory all at once. It allows you to iterate over a potentially infinite sequence without needing to generate or store all the values in advance.

# How to define a generator: Generators are defined using a special kind of function called a generator function. Instead of using the return keyword, generator functions use the yield keyword to yield a value. When a generator function is called, it returns a generator object.



                                        #  why 


# Advantages of generators: Generators offer several advantages over regular functions and lists:

# Memory efficiency: Generators generate values on-the-fly, so they don't require storing the entire sequence in memory. This is especially useful when dealing with large or infinite sequences.
# Lazy evaluation: Generators produce values only when requested, allowing for efficient and on-demand computation.
# Iteration support: Generators are iterable, meaning you can use them directly in for loops or other constructs that expect iterables.



# comman way of iteration 

def square_number(nums) : 
    result = []
    for i in nums:
        result.append(i*i)
    return result

my_num = square_number([1,2,3,4,5])

print(my_num)


# And Decorator comes in picture 

def square_number2(num):
    for i in num:
        yield i*i
   
    
my_num = square_number2([1,2,3,4,5]) 

print(my_num) # gives a generator object which conatains <generator object square_number2 at 0x0000018418998040>
#  one way to iterate over generator 
print(next(my_num))  
print(next(my_num))  
print(next(my_num))  

#  another way to iterate 

for i in square_number2([1,2,3,4,5]):
    print(f"I am form generator {i}")
    
#  third way  (IMP it's look like tuples but it is not )

generator = (x*x for x in range(1 , 10))
for num in generator:
    print(num)

#  Comprehension with tuple can be done by this 

tuple = tuple(x*x for x in range(1 , 10))

list = list(x*x for x in range(1 , 10))

# print(tuple)



# Generator as an argument: Generators can be used as arguments in functions that expect iterables. For example, you can pass a generator to the sum() function to calculate the sum of values generated by the generator.


def square_generator():
    for i in range(1, 6):
        yield i ** 2

generator = square_generator()
total = sum(generator)
print(total)  # Output: 55



# Chaining generators: Generators can be chained together using the yield from statement (available from Python 3.3 onwards) to delegate the iteration to another generator. This allows for modular and reusable generator functions.

# Here's an example of chaining two generators:

def square_generator():
    for i in range(1, 6):
        yield i ** 2

def even_square_generator():
    yield from (num for num in square_generator() if num % 2 == 0)

generator = even_square_generator()

for num in generator:
    print(num)



# Coroutine-like behavior: Generators can act as coroutines, which are routines that can be paused and resumed to perform cooperative multitasking. You can send values into a generator using the generator.send(value) method. This allows for two-way communication between the caller and the generator.

# def coroutine():
#     value = yield
#     print(f"Pecived Message is : {value}")
    
# generator2 = coroutine()
# next(generator2)
# generator2.send("Harsh")


def coroutine_example():
    value = yield
    print('Received:', value)

generator = coroutine_example()
next(generator)
generator.send('Hello!')



# generator abhi baki hai 

